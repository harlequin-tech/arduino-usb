<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LUFA (Formerly MyUSB) Library: Summary of Compile Tokens</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LUFA (Formerly MyUSB) Library&#160;<span id="projectnumber">100807</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_page__token_summary.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<h1>Summary of Compile Tokens </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p>The following lists all the possible tokens which can be defined in a project makefile, and passed to the compiler via the -D switch, to alter the LUFA library code. These tokens may alter the library behaviour, or remove features unused by a given application in order to save flash space.</p>
<h2><a class="anchor" id="Sec_SummaryNonUSBTokens"></a>
Non USB Related Tokens</h2>
<p>This section describes compile tokens which affect non-USB sections of the LUFA library.</p>
<p><b>DISABLE_TERMINAL_CODES</b> - ( <a class="el" href="group___group___terminal.html">ANSI Terminal Escape Codes - LUFA/Drivers/Misc/TerminalCodes.h</a> ) <br/>
 If an application contains ANSI terminal control codes listed in <a class="el" href="_terminal_codes_8h.html" title="ANSI terminal special escape code macros.">TerminalCodes.h</a>, it might be desired to remove them at compile time for use with a terminal which is non-ANSI control code aware, without modifying the source code. If this token is defined, all ANSI control codes in the application code from the <a class="el" href="_terminal_codes_8h.html" title="ANSI terminal special escape code macros.">TerminalCodes.h</a> header are removed from the source code at compile time.</p>
<h2><a class="anchor" id="Sec_SummaryUSBClassTokens"></a>
USB Class Driver Related Tokens</h2>
<p>This section describes compile tokens which affect USB class-specific drivers in the LUFA library.</p>
<p><b>HID_HOST_BOOT_PROTOCOL_ONLY</b> - ( <a class="el" href="group___group___u_s_b_class_h_i_d_host.html">HID Class Host Mode Driver</a> ) <br/>
 By default, the USB HID Host class driver is designed to work with HID devices using either the Boot or Report HID communication protocols. On devices where the Report protocol is not used (i.e. in applications where only basic Mouse or Keyboard operation is desired, using boot compatible devices), the code responsible for the Report protocol mode can be removed to save space in the compiled application by defining this token. When defined, it is still necessary to explicitly put the attached device into Boot protocol mode via a call to <a class="el" href="group___group___u_s_b_class_h_i_d_host.html#ga3ff69d38732ff6df8df69342e78df86f">HID_Host_SetBootProtocol()</a>.</p>
<p><b>HID_STATETABLE_STACK_DEPTH</b>=<em>x</em> - ( <a class="el" href="group___group___h_i_d_parser.html">HID Report Parser</a> ) <br/>
 HID reports may contain PUSH and POP elements, to store and retrieve the current HID state table onto a stack. This allows for reports to save the state table before modifying it slightly for a data item, and then restore the previous state table in a compact manner. This token may be defined to a non-zero 8-bit value to give the maximum depth of the state table stack. If not defined, this defaults to the value indicated in the HID.h file documentation.</p>
<p><b>HID_USAGE_STACK_DEPTH</b>=<em>x</em> - ( <a class="el" href="group___group___h_i_d_parser.html">HID Report Parser</a> ) <br/>
 HID reports generally contain many USAGE elements, which are assigned to INPUT, OUTPUT and FEATURE items in succession when multiple items are defined at once (via REPORT COUNT elements). This allows for several items to be defined with different usages in a compact manner. This token may be defined to a non-zero 8-bit value to set the maximum depth of the usage stack, indicating the maximum number of USAGE items which can be stored temporarily until the next INPUT, OUTPUT and FEATURE item. If not defined, this defaults to the value indicated in the HID.h file documentation.</p>
<p><b>HID_MAX_COLLECTIONS</b>=<em>x</em> - ( <a class="el" href="group___group___h_i_d_parser.html">HID Report Parser</a> ) <br/>
 HID reports generally contain several COLLECTION elements, used to group related data items together. Collection information is stored separately in the processed usage structure (and referred to by the data elements in the structure) to save space. This token may be defined to a non-zero 8-bit value to set the maximum number of COLLECTION items which can be processed by the parser into the resultant processed report structure. If not defined, this defaults to the value indicated in the HID.h file documentation.</p>
<p><b>HID_MAX_REPORTITEMS</b>=<em>x</em> - ( <a class="el" href="group___group___h_i_d_parser.html">HID Report Parser</a> ) <br/>
 All HID reports contain one or more INPUT, OUTPUT and/or FEATURE items describing the data which can be sent to and from the HID device. Each item has associated usages, bit offsets in the item reports and other associated data indicating the manner in which the report data should be interpreted by the host. This token may be defined to a non-zero 8-bit value to set the maximum number of data elements which can be stored in the processed HID report structure, including INPUT, OUTPUT and (if enabled) FEATURE items. If a item has a multiple count (i.e. a REPORT COUNT of more than 1), each item in the report count is placed separately in the processed HID report table. If not defined, this defaults to the value indicated in the HID.h file documentation.</p>
<p><b>HID_MAX_REPORT_IDS</b>=<em>x</em> - ( <a class="el" href="group___group___h_i_d_parser.html">HID Report Parser</a> ) <br/>
 HID reports may contain several report IDs, to logically distinguish grouped device data from one another - for example, a combination keyboard and mouse might use report IDs to separate the keyboard reports from the mouse reports. In order to determine the size of each report, and thus know how many bytes must be read or written, the size of each report (IN, OUT and FEATURE) must be calculated and stored. This token may be defined to a non-zero 8-bit value to set the maximum number of report IDs in a device which can be processed and their sizes calculated/stored into the resultant processed report structure. If not defined, this defaults to the value indicated in the HID.h file documentation.</p>
<h2><a class="anchor" id="Sec_SummaryUSBTokens"></a>
General USB Driver Related Tokens</h2>
<p>This section describes compile tokens which affect USB driver stack as a whole in the LUFA library.</p>
<p><b>NO_STREAM_CALLBACKS</b> - ( <a class="el" href="group___group___endpoint_packet_management.html">Endpoint Packet Management</a> , <a class="el" href="group___group___pipe_packet_management.html">Pipe Packet Management</a> )<br/>
 Both the endpoint and the pipe driver code contains stream functions, allowing for arrays of data to be sent to or from the host easily via a single function call (rather than complex routines worrying about sending full packets, waiting for the endpoint/ pipe to become ready, etc.). By default, these stream functions require a callback function which is executed after each byte processed, allowing for early-aborts of stream transfers by the application. If callbacks are not required in an application, they can be removed by defining this token, reducing the compiled binary size. When removed, the stream functions no longer accept a callback function as a parameter.</p>
<p><b>FAST_STREAM_TRANSFERS</b> - ( <a class="el" href="group___group___endpoint_packet_management.html">Endpoint Packet Management</a> , <a class="el" href="group___group___pipe_packet_management.html">Pipe Packet Management</a> )<br/>
 By default, streams are transferred internally via a loop, sending or receiving one byte per iteration before checking for a bank full or empty condition. This allows for multiple stream functions to be chained together easily, as there are no alignment issues. However, this can lead to heavy performance penalties in applications where large streams are used frequently. When this compile time option is used, bytes are sent or received in groups of 8 bytes at a time increasing performance at the expense of a larger flash memory consumption due to the extra code required to deal with byte alignment.</p>
<p><b>USE_STATIC_OPTIONS</b>=<em>x</em> - ( <a class="el" href="group___group___u_s_b_management.html">USB Interface Management</a> ) <br/>
 By default, the <a class="el" href="group___group___u_s_b_management.html#gaa6fa034a919f41e17908bdcd7d5ae151">USB_Init()</a> function accepts dynamic options at runtime to alter the library behaviour, including whether the USB pad voltage regulator is enabled, and the device speed when in device mode. By defining this token to a mask comprised of the USB options mask defines usually passed as the Options parameter to <a class="el" href="group___group___u_s_b_management.html#gaa6fa034a919f41e17908bdcd7d5ae151">USB_Init()</a>, the resulting compiled binary can be decreased in size by removing the dynamic options code, and replacing it with the statically set options. When defined, the <a class="el" href="group___group___u_s_b_management.html#gaa6fa034a919f41e17908bdcd7d5ae151">USB_Init()</a> function no longer accepts an Options parameter.</p>
<p><b>USB_DEVICE_ONLY</b> - ( <a class="el" href="group___group___u_s_b_management.html">USB Interface Management</a> ) <br/>
 For the USB AVR models supporting both device and host USB modes, the <a class="el" href="group___group___u_s_b_management.html#gaa6fa034a919f41e17908bdcd7d5ae151">USB_Init()</a> function contains a Mode parameter which specifies the mode the library should be initialized to. If only device mode is required, the code for USB host mode can be removed from the binary to save space. When defined, the <a class="el" href="group___group___u_s_b_management.html#gaa6fa034a919f41e17908bdcd7d5ae151">USB_Init()</a> function no longer accepts a Mode parameter. This define is irrelevant on smaller USB AVRs which do not support host mode.</p>
<p><b>USB_HOST_ONLY</b> - ( <a class="el" href="group___group___u_s_b_management.html">USB Interface Management</a> ) <br/>
 Same as USB_DEVICE_ONLY, except the library is fixed to USB host mode rather than USB device mode. Not available on some USB AVR models.</p>
<p><b>USB_STREAM_TIMEOUT_MS</b>=<em>x</em> - ( <a class="el" href="group___group___u_s_b_management.html">USB Interface Management</a> ) <br/>
 When endpoint and/or pipe stream functions are used, by default there is a timeout between each transfer which the connected device or host must satisfy, or the stream function aborts the remaining data transfer. This token may be defined to a non-zero 16-bit value to set the timeout period for stream transfers, specified in milliseconds. If not defined, the default value specified in LowLevel.h is used instead.</p>
<p><b>NO_LIMITED_CONTROLLER_CONNECT</b> - ( <a class="el" href="group___group___events.html">USB Events</a> ) <br/>
 On the smaller USB AVRs, the USB controller lacks VBUS events to determine the physical connection state of the USB bus to a host. In lieu of VBUS events, the library attempts to determine the connection state via the bus suspension and wake up events instead. This however may be slightly inaccurate due to the possibility of the host suspending the bus while the device is still connected. If accurate connection status is required, the VBUS line of the USB connector should be routed to an AVR pin to detect its level, so that the USB_DeviceState global can be accurately set and the <a class="el" href="group___group___events.html#gaeff97648c9250a3d398bb0b74f040899">EVENT_USB_Device_Connect()</a> and <a class="el" href="group___group___events.html#gae88405d14d8d6dada9313520cb1501ec">EVENT_USB_Device_Disconnect()</a> events manually raised by the RAISE_EVENT macro. When defined, this token disables the library's auto-detection of the connection state by the aforementioned suspension and wake up events.</p>
<h2><a class="anchor" id="Sec_SummaryUSBDeviceTokens"></a>
USB Device Mode Driver Related Tokens</h2>
<p>This section describes compile tokens which affect USB driver stack of the LUFA library when used in Device mode.</p>
<p><b>USE_RAM_DESCRIPTORS</b> - ( <a class="el" href="group___group___descriptors.html">USB Descriptors</a> ) <br/>
 Define this token to indicate to the USB driver that all device descriptors are stored in RAM, rather than being located in any one of the AVR's memory spaces. RAM descriptors may be desirable in applications where the descriptors need to be modified at runtime.</p>
<p><b>USE_FLASH_DESCRIPTORS</b> - ( <a class="el" href="group___group___descriptors.html">USB Descriptors</a> ) <br/>
 Similar to USE_RAM_DESCRIPTORS, but all descriptors are stored in the AVR's FLASH memory rather than RAM.</p>
<p><b>USE_EEPROM_DESCRIPTORS</b> - ( <a class="el" href="group___group___descriptors.html">USB Descriptors</a> ) <br/>
 Similar to USE_RAM_DESCRIPTORS, but all descriptors are stored in the AVR's EEPROM memory rather than RAM.</p>
<p><b>NO_INTERNAL_SERIAL</b> - ( <a class="el" href="group___group___descriptors.html">USB Descriptors</a> ) <br/>
 Some AVR models contain a unique 20-digit serial number which can be used as the device serial number, while in device mode. This allows the host to uniquely identify the device regardless of if it is moved between USB ports on the same computer, allowing allocated resources (such as drivers, COM Port number allocations) to be preserved. This is not needed in many apps, and so the code that performs this task can be disabled by defining this option and passing it to the compiler via the -D switch.</p>
<p><b>FIXED_CONTROL_ENDPOINT_SIZE</b>=<em>x</em> - ( <a class="el" href="group___group___endpoint_management.html">Endpoint Management</a> ) <br/>
 By default, the library determines the size of the control endpoint (when in device mode) by reading the device descriptor. Normally this reduces the amount of configuration required for the library, allows the value to change dynamically (if descriptors are stored in EEPROM or RAM rather than flash memory) and reduces code maintenance. However, this token can be defined to a non-zero value instead to give the size in bytes of the control endpoint, to reduce the size of the compiled binary.</p>
<p><b>DEVICE_STATE_AS_GPIOR</b> - ( <a class="el" href="group___group___device.html">Device Management</a> ) <br/>
 One of the most frequently used global variables in the stack is the USB_DeviceState global, which indicates the current state of the Device State Machine. To reduce the amount of code and time required to access and modify this global in an application, this token may be defined to a value between 0 and 2 to fix the state variable into one of the three general purpose IO registers inside the AVR reserved for application use. When defined, the corresponding GPIOR register should not be used within the user application except implicitly via the library APIs.</p>
<p><b>FIXED_NUM_CONFIGURATIONS</b>=<em>x</em> - ( <a class="el" href="group___group___device.html">Device Management</a> ) <br/>
 By default, the library determines the number of configurations a USB device supports by reading the device descriptor. This reduces the amount of configuration required to set up the library, and allows the value to change dynamically (if descriptors are stored in EEPROM or RAM rather than flash memory) and reduces code maintenance. However, this value may be fixed via this token in the project makefile to reduce the compiled size of the binary at the expense of flexibility.</p>
<p><b>CONTROL_ONLY_DEVICE</b> <br/>
 In some limited USB device applications, there are no device endpoints other than the control endpoint; i.e. all device communication is through control endpoint requests. Defining this token will remove several features related to the selection and control of device endpoints internally, saving space. Generally, this is usually only useful in (some) bootloaders and is best avoided.</p>
<p><b>INTERRUPT_CONTROL_ENDPOINT</b> - ( <a class="el" href="group___group___u_s_b_management.html">USB Interface Management</a> ) <br/>
 Some applications prefer to not call the <a class="el" href="group___group___u_s_b_management.html#gac4059f84a2fc0b926c31868c744f5853">USB_USBTask()</a> management task regularly while in device mode, as it can complicate code significantly. Instead, when device mode is used this token can be passed to the library via the -D switch to allow the library to manage the USB control endpoint entirely via USB controller interrupts asynchronously to the user application. When defined, <a class="el" href="group___group___u_s_b_management.html#gac4059f84a2fc0b926c31868c744f5853">USB_USBTask()</a> does not need to be called when in USB device mode.</p>
<p><b>NO_DEVICE_REMOTE_WAKEUP</b> - (<a class="el" href="group___group___device.html">Device Management</a> ) <br/>
 Many devices do not require the use of the Remote Wakeup features of USB, used to wake up the USB host when suspended. On these devices, the code required to manage device Remote Wakeup can be disabled by defining this token and passing it to the library via the -D switch.</p>
<p><b>NO_DEVICE_SELF_POWER</b> - (<a class="el" href="group___group___device.html">Device Management</a> ) <br/>
 USB devices may be bus powered, self powered, or a combination of both. When a device can be both bus powered and self powered, the host may query the device to determine the current power source, via <a class="el" href="group___group___device.html#ga4dd1fc963f6ec0a937904d7aeaf8650d">USB_CurrentlySelfPowered</a>. For solely bus powered devices, this global and the code required to manage it may be disabled by passing this token to the library via the -D switch.</p>
<h2><a class="anchor" id="Sec_SummaryUSBHostTokens"></a>
USB Host Mode Driver Related Tokens</h2>
<p>This section describes compile tokens which affect USB driver stack of the LUFA library when used in Host mode.</p>
<p><b>HOST_STATE_AS_GPIOR</b> - ( <a class="el" href="group___group___host.html">Host Management</a> ) <br/>
 One of the most frequently used global variables in the stack is the USB_HostState global, which indicates the current state of the Host State Machine. To reduce the amount of code and time required to access and modify this global in an application, this token may be defined to a value between 0 and 2 to fix the state variable into one of the three general purpose IO registers inside the AVR reserved for application use. When defined, the corresponding GPIOR register should not be used within the user application except implicitly via the library APIs.</p>
<p><b>USB_HOST_TIMEOUT_MS</b>=<em>x</em> - ( <a class="el" href="group___group___host.html">Host Management</a> ) <br/>
 When a control transfer is initiated in host mode to an attached device, a timeout is used to abort the transfer if the attached device fails to respond within the timeout period. This token may be defined to a non-zero 16-bit value to set the timeout period for control transfers, specified in milliseconds. If not defined, the default value specified in <a class="el" href="_host_8h.html" title="USB host mode definitions.">Host.h</a> is used instead.</p>
<p><b>HOST_DEVICE_SETTLE_DELAY_MS</b>=<em>x</em> - ( <a class="el" href="group___group___host.html">Host Management</a> ) <br/>
 Some devices require a delay of up to 5 seconds after they are connected to VBUS before the enumeration process can be started, or they will fail to enumerate correctly. By placing a delay before the enumeration process, it can be ensured that the bus has settled back to a known idle state before communications occur with the device. This token may be defined to a 16-bit value to set the device settle period, specified in milliseconds. If not defined, the default value specified in <a class="el" href="_host_8h.html" title="USB host mode definitions.">Host.h</a> is used instead. </p>
</div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="_page__developing_with_l_u_f_a.html">Developing With LUFA</a>      </li>
      <li class="footer">Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
