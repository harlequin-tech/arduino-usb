<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LUFA (Formerly MyUSB) Library: CDC Class Host Mode Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LUFA (Formerly MyUSB) Library&#160;<span id="projectnumber">100807</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group___group___u_s_b_class_c_d_c_host.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>CDC Class Host Mode Driver</h1>  </div>
<div class="ingroups"><a class="el" href="group___group___u_s_b_class_c_d_c.html">CDC-ACM (Virtual Serial) Class Driver - LUFA/Drivers/Class/CDC.h</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">CDC Class Host Mode Configuration and State Structure.  <a href="struct_u_s_b___class_info___c_d_c___host__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_c_d_c_host.html#ga4808d1fd25b076ea3c78d317b3753e73">CDCHost_EnumerationFailure_ErrorCodes_t</a> { <br/>
&#160;&#160;<a class="el" href="group___group___u_s_b_class_c_d_c_host.html#gga4808d1fd25b076ea3c78d317b3753e73ab48e01039ec1629611d6da10ccc7a663">CDC_ENUMERROR_NoError</a> =  0, 
<br/>
&#160;&#160;<a class="el" href="group___group___u_s_b_class_c_d_c_host.html#gga4808d1fd25b076ea3c78d317b3753e73a5a6b3de59a087e356fb3a8888133d09e">CDC_ENUMERROR_InvalidConfigDescriptor</a> =  1, 
<br/>
&#160;&#160;<a class="el" href="group___group___u_s_b_class_c_d_c_host.html#gga4808d1fd25b076ea3c78d317b3753e73aea6f4f791cace8f6b071e0805d6e5c44">CDC_ENUMERROR_NoCDCInterfaceFound</a> =  2, 
<br/>
&#160;&#160;<a class="el" href="group___group___u_s_b_class_c_d_c_host.html#gga4808d1fd25b076ea3c78d317b3753e73af03df2663f49d5c4f53be0cbd370be70">CDC_ENUMERROR_EndpointsNotFound</a> =  3
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_c_d_c_host.html#gac1d8f6a65e1e5baa835bc705b2cd5714">CDC_Host_USBTask</a> (<a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const CDCInterfaceInfo) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_c_d_c_host.html#ga348cf0574880675172c800c06612677f">CDC_Host_ConfigurePipes</a> (<a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const CDCInterfaceInfo, uint16_t ConfigDescriptorSize, void *DeviceConfigDescriptor) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_c_d_c_host.html#ga87422f19d4f1050a6b0d59afd85dd56d">CDC_Host_SetLineEncoding</a> (<a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const CDCInterfaceInfo) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_c_d_c_host.html#ga1c049ab0129e344215f7361f692c5f04">CDC_Host_SendControlLineStateChange</a> (<a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const CDCInterfaceInfo) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_c_d_c_host.html#ga4b6f600fe7d0c14f7e574b542c64893a">CDC_Host_SendBreak</a> (<a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const CDCInterfaceInfo, const uint8_t Duration) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_c_d_c_host.html#ga7d1b73b6f92d3221ef20e093a11d8f35">CDC_Host_SendString</a> (<a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const CDCInterfaceInfo, const char *const Data, const uint16_t Length) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_c_d_c_host.html#gabdd1e6dc984d3fe716c4c00362ee18a0">CDC_Host_SendByte</a> (<a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const CDCInterfaceInfo, const uint8_t Data) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_c_d_c_host.html#ga60e22ed372a52178d59b251e0dc07f66">CDC_Host_BytesReceived</a> (<a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const CDCInterfaceInfo) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_c_d_c_host.html#gac01990d80adec5a3004cf4b4d3bd6511">CDC_Host_ReceiveByte</a> (<a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const CDCInterfaceInfo) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_c_d_c_host.html#gaa416cb5aebb3f8a2afa8956127c240f5">CDC_Host_Flush</a> (<a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const CDCInterfaceInfo) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_c_d_c_host.html#ga8abc5328e4de74d00406f6a708c6eba3">CDC_Host_CreateStream</a> (<a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const CDCInterfaceInfo, FILE *const Stream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_c_d_c_host.html#ga45ee7672a7aa14040fd9772785f406cd">CDC_Host_CreateBlockingStream</a> (<a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const CDCInterfaceInfo, FILE *const Stream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___u_s_b_class_c_d_c_host.html#ga33a4e8ea9bb822ac7dd6369d86aa9f16">EVENT_CDC_Host_ControLineStateChanged</a> (<a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const CDCInterfaceInfo) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h2><a class="anchor" id="Sec_Dependencies"></a>
Module Source Dependencies</h2>
<p>The following files must be built with any user project that uses this module:</p>
<ul>
<li>LUFA/Drivers/USB/Class/Host/CDC.c <em>(Makefile source module name: LUFA_SRC_USBCLASS)</em></li>
</ul>
<h2><a class="anchor" id="Module"></a>
Description</h2>
<p>Host Mode USB Class driver framework interface, for the CDC USB Class driver. </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga4808d1fd25b076ea3c78d317b3753e73"></a><!-- doxytag: member="CDC.h::CDCHost_EnumerationFailure_ErrorCodes_t" ref="ga4808d1fd25b076ea3c78d317b3753e73" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___group___u_s_b_class_c_d_c_host.html#ga4808d1fd25b076ea3c78d317b3753e73">CDCHost_EnumerationFailure_ErrorCodes_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum for the possible error codes returned by the <a class="el" href="group___group___u_s_b_class_c_d_c_host.html#ga348cf0574880675172c800c06612677f">CDC_Host_ConfigurePipes()</a> function. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga4808d1fd25b076ea3c78d317b3753e73ab48e01039ec1629611d6da10ccc7a663"></a><!-- doxytag: member="CDC_ENUMERROR_NoError" ref="gga4808d1fd25b076ea3c78d317b3753e73ab48e01039ec1629611d6da10ccc7a663" args="" -->CDC_ENUMERROR_NoError</em>&nbsp;</td><td>
<p>Configuration Descriptor was processed successfully. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga4808d1fd25b076ea3c78d317b3753e73a5a6b3de59a087e356fb3a8888133d09e"></a><!-- doxytag: member="CDC_ENUMERROR_InvalidConfigDescriptor" ref="gga4808d1fd25b076ea3c78d317b3753e73a5a6b3de59a087e356fb3a8888133d09e" args="" -->CDC_ENUMERROR_InvalidConfigDescriptor</em>&nbsp;</td><td>
<p>The device returned an invalid Configuration Descriptor. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga4808d1fd25b076ea3c78d317b3753e73aea6f4f791cace8f6b071e0805d6e5c44"></a><!-- doxytag: member="CDC_ENUMERROR_NoCDCInterfaceFound" ref="gga4808d1fd25b076ea3c78d317b3753e73aea6f4f791cace8f6b071e0805d6e5c44" args="" -->CDC_ENUMERROR_NoCDCInterfaceFound</em>&nbsp;</td><td>
<p>A compatible CDC interface was not found in the device's Configuration Descriptor. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga4808d1fd25b076ea3c78d317b3753e73af03df2663f49d5c4f53be0cbd370be70"></a><!-- doxytag: member="CDC_ENUMERROR_EndpointsNotFound" ref="gga4808d1fd25b076ea3c78d317b3753e73af03df2663f49d5c4f53be0cbd370be70" args="" -->CDC_ENUMERROR_EndpointsNotFound</em>&nbsp;</td><td>
<p>Compatible CDC endpoints were not found in the device's CDC interface. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga60e22ed372a52178d59b251e0dc07f66"></a><!-- doxytag: member="CDC.h::CDC_Host_BytesReceived" ref="ga60e22ed372a52178d59b251e0dc07f66" args="(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t CDC_Host_BytesReceived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const&#160;</td>
          <td class="paramname"><em>CDCInterfaceInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines the number of bytes received by the CDC interface from the device, waiting to be read. This indicates the number of bytes in the IN pipe bank only, and thus the number of calls to <a class="el" href="group___group___u_s_b_class_c_d_c_host.html#gac01990d80adec5a3004cf4b4d3bd6511">CDC_Host_ReceiveByte()</a> which are guaranteed to succeed immediately. If multiple bytes are to be received, they should be buffered by the user application, as the pipe bank will not be released back to the USB controller until all bytes are read.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>This function must only be called when the Host state machine is in the HOST_STATE_Configured state or the call will fail.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CDCInterfaceInfo</td><td>Pointer to a structure containing a CDC Class host configuration and state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Total number of buffered bytes received from the device. </dd></dl>

</div>
</div>
<a class="anchor" id="ga348cf0574880675172c800c06612677f"></a><!-- doxytag: member="CDC.h::CDC_Host_ConfigurePipes" ref="ga348cf0574880675172c800c06612677f" args="(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo, uint16_t ConfigDescriptorSize, void *DeviceConfigDescriptor) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t CDC_Host_ConfigurePipes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const&#160;</td>
          <td class="paramname"><em>CDCInterfaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ConfigDescriptorSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>DeviceConfigDescriptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Host interface configuration routine, to configure a given CDC host interface instance using the Configuration Descriptor read from an attached USB device. This function automatically updates the given CDC Host instance's state values and configures the pipes required to communicate with the interface if it is found within the device. This should be called once after the stack has enumerated the attached device, while the host state machine is in the Addressed state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CDCInterfaceInfo</td><td>Pointer to a structure containing an CDC Class host configuration and state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ConfigDescriptorSize</td><td>Length of the attached device's Configuration Descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DeviceConfigDescriptor</td><td>Pointer to a buffer containing the attached device's Configuration Descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___u_s_b_class_c_d_c_host.html#ga4808d1fd25b076ea3c78d317b3753e73">CDCHost_EnumerationFailure_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga45ee7672a7aa14040fd9772785f406cd"></a><!-- doxytag: member="CDC.h::CDC_Host_CreateBlockingStream" ref="ga45ee7672a7aa14040fd9772785f406cd" args="(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo, FILE *const Stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CDC_Host_CreateBlockingStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const&#160;</td>
          <td class="paramname"><em>CDCInterfaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *const&#160;</td>
          <td class="paramname"><em>Stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Identical to <a class="el" href="group___group___u_s_b_class_c_d_c_host.html#ga8abc5328e4de74d00406f6a708c6eba3">CDC_Host_CreateStream()</a>, except that reads are blocking until the calling stream function terminates the transfer. While blocking, the USB and CDC service tasks are called repeatedly to maintain USB communications.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CDCInterfaceInfo</td><td>Pointer to a structure containing a CDC Class configuration and state. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Stream</td><td>Pointer to a FILE structure where the created stream should be placed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8abc5328e4de74d00406f6a708c6eba3"></a><!-- doxytag: member="CDC.h::CDC_Host_CreateStream" ref="ga8abc5328e4de74d00406f6a708c6eba3" args="(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo, FILE *const Stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CDC_Host_CreateStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const&#160;</td>
          <td class="paramname"><em>CDCInterfaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *const&#160;</td>
          <td class="paramname"><em>Stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a standard character stream for the given CDC Device instance so that it can be used with all the regular functions in the avr-libc &lt;stdio.h&gt; library that accept a FILE stream as a destination (e.g. fprintf). The created stream is bidirectional and can be used for both input and output functions.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The created stream can be given as stdout if desired to direct the standard output from all &lt;stdio.h&gt; functions to the given CDC interface.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CDCInterfaceInfo</td><td>Pointer to a structure containing a CDC Class configuration and state. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Stream</td><td>Pointer to a FILE structure where the created stream should be placed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa416cb5aebb3f8a2afa8956127c240f5"></a><!-- doxytag: member="CDC.h::CDC_Host_Flush" ref="gaa416cb5aebb3f8a2afa8956127c240f5" args="(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t CDC_Host_Flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const&#160;</td>
          <td class="paramname"><em>CDCInterfaceInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flushes any data waiting to be sent, ensuring that the send buffer is cleared.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>This function must only be called when the Host state machine is in the HOST_STATE_Configured state or the call will fail.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CDCInterfaceInfo</td><td>Pointer to a structure containing a CDC Class host configuration and state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_r_w.html#gafe05d0620e5882aced3764a691a11152">Pipe_WaitUntilReady_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gac01990d80adec5a3004cf4b4d3bd6511"></a><!-- doxytag: member="CDC.h::CDC_Host_ReceiveByte" ref="gac01990d80adec5a3004cf4b4d3bd6511" args="(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CDC_Host_ReceiveByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const&#160;</td>
          <td class="paramname"><em>CDCInterfaceInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads a byte of data from the device. If no data is waiting to be read of if a USB device is not connected, the function returns a negative value. The <a class="el" href="group___group___u_s_b_class_c_d_c_host.html#ga60e22ed372a52178d59b251e0dc07f66">CDC_Host_BytesReceived()</a> function may be queried in advance to determine how many bytes are currently buffered in the CDC interface's data receive pipe.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>This function must only be called when the Host state machine is in the HOST_STATE_Configured state or the call will fail.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CDCInterfaceInfo</td><td>Pointer to a structure containing a CDC Class host configuration and state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Next received byte from the device, or a negative value if no data received. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4b6f600fe7d0c14f7e574b542c64893a"></a><!-- doxytag: member="CDC.h::CDC_Host_SendBreak" ref="ga4b6f600fe7d0c14f7e574b542c64893a" args="(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo, const uint8_t Duration) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t CDC_Host_SendBreak </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const&#160;</td>
          <td class="paramname"><em>CDCInterfaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>Duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends a Send Break request to the device. This is generally used to separate data data or to indicate a special condition to the receiving device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CDCInterfaceInfo</td><td>Pointer to a structure containing a CDC Class host configuration and state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Duration</td><td>Duration of the break, in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_control_req.html#gab48bdc395027a1729b8324ff6efa15ec">USB_Host_SendControlErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gabdd1e6dc984d3fe716c4c00362ee18a0"></a><!-- doxytag: member="CDC.h::CDC_Host_SendByte" ref="gabdd1e6dc984d3fe716c4c00362ee18a0" args="(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo, const uint8_t Data) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t CDC_Host_SendByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const&#160;</td>
          <td class="paramname"><em>CDCInterfaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends a given byte to the attached USB device, if connected. If a device is not connected when the function is called, the byte is discarded. Bytes will be queued for transmission to the device until either the pipe bank becomes full, or the <a class="el" href="group___group___u_s_b_class_c_d_c_host.html#gaa416cb5aebb3f8a2afa8956127c240f5">CDC_Host_Flush()</a> function is called to flush the pending data to the host. This allows for multiple bytes to be packed into a single pipe packet, increasing data throughput.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>This function must only be called when the Host state machine is in the HOST_STATE_Configured state or the call will fail.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CDCInterfaceInfo</td><td>Pointer to a structure containing a CDC Class host configuration and state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>Byte of data to send to the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_r_w.html#gafe05d0620e5882aced3764a691a11152">Pipe_WaitUntilReady_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c049ab0129e344215f7361f692c5f04"></a><!-- doxytag: member="CDC.h::CDC_Host_SendControlLineStateChange" ref="ga1c049ab0129e344215f7361f692c5f04" args="(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t CDC_Host_SendControlLineStateChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const&#160;</td>
          <td class="paramname"><em>CDCInterfaceInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends a Serial Control Line State Change notification to the device. This should be called when the virtual serial control lines (DTR, RTS, etc.) have changed states. Line states persist until they are cleared via a second notification. This should be called each time the CDC class driver's ControlLineStates.HostToDevice value is updated to push the new states to the USB device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CDCInterfaceInfo</td><td>Pointer to a structure containing a CDC Class host configuration and state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_control_req.html#gab48bdc395027a1729b8324ff6efa15ec">USB_Host_SendControlErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d1b73b6f92d3221ef20e093a11d8f35"></a><!-- doxytag: member="CDC.h::CDC_Host_SendString" ref="ga7d1b73b6f92d3221ef20e093a11d8f35" args="(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo, const char *const Data, const uint16_t Length) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t CDC_Host_SendString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const&#160;</td>
          <td class="paramname"><em>CDCInterfaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends a given string to the attached USB device, if connected. If a device is not connected when the function is called, the string is discarded. Bytes will be queued for transmission to the device until either the pipe bank becomes full, or the <a class="el" href="group___group___u_s_b_class_c_d_c_host.html#gaa416cb5aebb3f8a2afa8956127c240f5">CDC_Host_Flush()</a> function is called to flush the pending data to the host. This allows for multiple bytes to be packed into a single pipe packet, increasing data throughput.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>This function must only be called when the Host state machine is in the HOST_STATE_Configured state or the call will fail.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CDCInterfaceInfo</td><td>Pointer to a structure containing a CDC Class host configuration and state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>Pointer to the string to send to the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Size in bytes of the string to send to the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga87422f19d4f1050a6b0d59afd85dd56d"></a><!-- doxytag: member="CDC.h::CDC_Host_SetLineEncoding" ref="ga87422f19d4f1050a6b0d59afd85dd56d" args="(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t CDC_Host_SetLineEncoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const&#160;</td>
          <td class="paramname"><em>CDCInterfaceInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the line encoding for the attached device's virtual serial port. This should be called when the LineEncoding values of the interface have been changed to push the new settings to the USB device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CDCInterfaceInfo</td><td>Pointer to a structure containing a CDC Class host configuration and state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_control_req.html#gab48bdc395027a1729b8324ff6efa15ec">USB_Host_SendControlErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gac1d8f6a65e1e5baa835bc705b2cd5714"></a><!-- doxytag: member="CDC.h::CDC_Host_USBTask" ref="gac1d8f6a65e1e5baa835bc705b2cd5714" args="(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CDC_Host_USBTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const&#160;</td>
          <td class="paramname"><em>CDCInterfaceInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>General management task for a given CDC host class interface, required for the correct operation of the interface. This should be called frequently in the main program loop, before the master USB management task <a class="el" href="group___group___u_s_b_management.html#gac4059f84a2fc0b926c31868c744f5853">USB_USBTask()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CDCInterfaceInfo</td><td>Pointer to a structure containing an CDC Class host configuration and state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga33a4e8ea9bb822ac7dd6369d86aa9f16"></a><!-- doxytag: member="CDC.h::EVENT_CDC_Host_ControLineStateChanged" ref="ga33a4e8ea9bb822ac7dd6369d86aa9f16" args="(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EVENT_CDC_Host_ControLineStateChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___class_info___c_d_c___host__t.html">USB_ClassInfo_CDC_Host_t</a> *const&#160;</td>
          <td class="paramname"><em>CDCInterfaceInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>CDC class driver event for a control line state change on a CDC host interface. This event fires each time the device notifies the host of a control line state change (containing the virtual serial control line states, such as DCD) and may be hooked in the user program by declaring a handler function with the same name and parameters listed here. The new control line states are available in the ControlLineStates.DeviceToHost value inside the CDC host interface structure passed as a parameter, set as a mask of CDC_CONTROL_LINE_IN_* masks.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CDCInterfaceInfo</td><td>Pointer to a structure containing a CDC Class host configuration and state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer">Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
